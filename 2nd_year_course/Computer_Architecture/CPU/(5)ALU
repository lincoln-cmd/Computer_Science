<산술과 논리 연산>


산술논리연산장치(Arithmetic and Logical Unit: ALU)
  - CPU 내부의 핵심 구성요소로서, 산술 연산과 논리 연산을 수행하는 하드웨어 모듈
  - ALU의 구성 요소
      - 산술 연산장치
      - 논리 연산장치
      - 시프트 레지스터(shift register): 비트들을 이동시키는(횡이동) 레지스터
      - 보수기(complementer): 이진수의 2의 보수를 반환하는 회로. 음수를 2진수를 표현하고, 음수의 덧셈을 할 때 사용
      - 상태 레지스터(status register): 연산 결과의 상태를 저장하는 레지스터


          산술 연산장치    <--->  ↑    <-- 입력 데이터
          논리 연산장치    <--->  |    <-- 입력 데이터
          보수기           <--->  |    --> 출력 데이터
          시프트 레지스터  <--->  |    --> 플래그들
          상태 레지스터    <--->  ↓    --> 제어 신호들


정수의 표현
  - 2진수 체계: 0, 1, 부호 및 소수점으로 수를 표현
  - 부호 비트(sign bit)
  - 음수 표현 방법
      - 부호화-크기 표현
      - 1의 보수 표현
      - 2의 보수 표현


부호화-크기 표현
  - 맨 좌측 비트: 부호 비트
  - 나머지 비트들: 수의 크기
  - 0에 대한 표현이 두 가지(0와 -0)

      10진수   |   부호화-크기
        4      |      0100
        3      |      0011
        2      |      0010
        1      |      0001
        0      |      0000
       -0      |      1000
       -1      |      1001
       -2      |      1010
       -3      |      1011
       -4      |      1100



1의 보수
  - 맨 좌측 비트: 부호 비트
  - 나머지 비트들: -1과 0을 반전
  - 0에 대한 표현이 두 가지(0000과 1111)

      10진수   |   1의 보수
        4      |     0100
        3      |     0011
        2      |     0010
        1      |     0001
        0      |     0000
       -0      |     1111
       -1      |     1110
       -2      |     1101
       -3      |     1100
       -4      |     1011



2의 보수
  - 맨 좌측 비트: 부호 비트
  - 나머지 비트들: 1과 0을 반전한 값에 1을 더함
  - 대부분의 컴퓨터에서 사용

      10진수   |   2의 보수
        4      |     0100
        3      |     0011
        2      |     0010
        1      |     0001
        0      |     0000
       -0      |     
       -1      |     1111
       -2      |     1110
       -3      |     1101
       -4      |     1100


컴퓨터에서 2의 보수를 사용하는 이유
  - 2의 보수의 장점
      - 음수 표현 및 쉬운 연산을 위함
      - 보수를 취하고 더하면 뺄셈이 됨
      ex) 5 - 3 = 5 + (-3) = (0101) + (1101) = (0010) = 2



기본적인 논리 연산

      A  B      NOT A      NOT B      A AND B      A OR B      A XOR B
      0  0        1          1           0           0            0
      0  1        1          0           0           1            1
      1  0        0          1           0           1            1
      1  1        0          0           1           1            0



선택적-세트 연산
  - 특정 비트들을 1로 세트
      A = 10010010
      b = 00001111
     ---------------
          10011111



선택적-보수 연산
  - 특정 비트들을 보수화
      A = 10010101
      B = 00001111
     ---------------
          10011010



마스크 연산
  - 특정 비트들을 0으로 리셋
      A = 11110101
      B = 00011111
     ---------------
          00010101



삽입 연산
  - 일부 비트들을 새로운 값들로 대체
      A = 10010101
      B = 00001111
     ---------------
          00000101
            ↓
      A = 00000101
      B = 11100000
     ---------------
          11100101



시프트 연산
  - 논리적 시프트(logical shift)
  - 순환 시프트(circular shift)
  - 산술적 시프트(arithmetic shift)
  - C 플래그를 포함한 시프트 연산


    논리적 시프트
      - 레지스터 내의 데이터 비트들을 왼쪽 혹은 오른쪽으로 한 칸씩 이동
      - 좌측 시프트(left shift)
      - 우측 시프트(right shift)
    
    
    순환 시프트
      - 회전(rotate) 시프트
      - 논리적 시프트와 같지만, 최상위 혹은 최하위 비트를 반대편 끝으로 이동
      - 순환 좌측-시프트(circular shift-left)
      - 순환 우측-시프트(circular shift-right)
    
    
    산술적 시프트
      - 부호를 가진 데이터에 대한 시프트 동작
          A = 1110 (-2)  (초기 상태)
              1100 (-4)  (산술적 좌측-시프트 결과)
              1110 (-2)  (첫 번재 산술적 우측-시프트 결과)
              1111 (-1)  (두 번째 산술적 우측-시프트 결과)
    
    
    C 플래그를 포함한 시프트 연산
      - 실재 CPU에서는 일반적으로 시프트 연산에 올림수(C) 플래그가 포함
      - C-플래그를 포함한 시프트 연산 (SHLC 연산, SHRC 연산)
      - C-플래그를 포함한 순환 시프트 연산 (RLC 연산, RRC 연산)



정수의 산술 연산
  - 덧셈: 병렬 가산기(parallel adder)
  - 뺄셈: 보수기(complementer), 병렬 가산기







